# SM3计算过程

SM3 算法的具体计算过程非常严谨，严格按照国标 **GM/T 0004-2012《SM3密码杂凑算法》** 执行。下面以 **输入消息 M = "abc"（ASCII 编码）** 为例，**完整、逐步地演示 SM3 的每一步计算过程**，包括填充、分组、扩展、压缩等核心环节。


## 输入消息
- 原始消息：`M = "abc"`
- ASCII 字节：`0x61 0x62 0x63`
- 比特长度：$ l = 3 \times 8 = 24 $ 比特

22
## 第一步：消息填充（Padding）

SM3 要求填充后长度为 **512 的整数倍**，规则如下：

1. 在消息末尾添加一个 `1` 比特 → 即字节 `0x80`（二进制 `1000 0000`）
2. 添加 $k$ 个 `0` 比特，使得：
   $$
   (l + 1 + k) \equiv 448 \pmod{512}
   $$
   - $24 + 1 + k \equiv 448 \mod 512$
   - $k = 448 - 25 = 423$ 比特（即 52 字节 + 7 个比特？但实际按字节对齐处理）
   - **注意**：填充必须按**比特**计算，但实现中通常按字节操作。由于 24 是 8 的倍数，加 `0x80` 后补 0 字节直到倒数第 8 字节。

3. 最后附加 **64 位（8 字节）大端序**的原始长度 $l = 24$

### 填充结果（共 512 比特 = 64 字节）：

| 字节位置 | 内容（十六进制） |
|----------|------------------|
| 0–2      | `61 62 63`       |
| 3        | `80`             |
| 4–55     | `00`（共 52 字节）|
| 56–63    | `00 00 00 00 00 00 00 18`（24 的 64 位表示）|

✅ 总长度 = 64 字节 = 512 比特 → **仅需 1 个分组**（$n=1$）


## 第二步：分组与初始划分

将填充后的 512 位划分为 **16 个 32 位字**（大端序）：

$$
B^{(0)} = (W_0, W_1, \dots, W_{15})
$$

每个字由 4 字节组成（高位在前）：

| j | 字节范围 | W_j（十六进制） |
|---|----------|------------------|
| 0 | 0–3      | `0x61626380`     |
| 1 | 4–7      | `0x00000000`     |
| 2 | 8–11     | `0x00000000`     |
| ... | ...    | ...              |
| 14| 56–59    | `0x00000000`     |
| 15| 60–63    | `0x00000018`     |

> 注意：字节序为**大端**，所以 `61 62 63 80` → `0x61626380`


## 第三步：消息扩展

### 1. 前 16 个字直接使用：
$$
W_0 = 0x61626380,\quad W_1 = 0,\quad \dots,\quad W_{15} = 0x00000018
$$

### 2. 计算 W₁₆ 到 W₆₇（共 52 个字）

使用递推公式（$16 \leq j \leq 67$）：

$$
W_j = P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} \lll 15)) \oplus (W_{j-13} \lll 7) \oplus W_{j-6}
$$

其中：
- $\lll$ 表示 **32 位循环左移**
- $P_1(X) = X \oplus (X \lll 15) \oplus (X \lll 23)$

### 3. 计算 W′ⱼ（0 ≤ j ≤ 63）

$$
W'_j = W_j \oplus W_{j+4}
$$

## 第四步：初始化链接变量 V⁰

使用标准 IV（8 个 32 位字）：

```
A = 0x7380166F
B = 0x4914B2B9
C = 0x172442D7
D = 0xDA8A0600
E = 0xA96F30BC
F = 0x163138AA
G = 0xE38DEE4D
H = 0xB0FB0E4E
```


## 第五步：64 轮压缩函数（核心！）

对 $j = 0$ 到 $63$，依次执行：

### 1. 计算常量 Tⱼ

- 若 $j < 16$：$T = 0x79CC4519$
- 否则：$T = 0x7A879D8A$

然后计算：$T_j^{\text{rot}} = T \lll j$


### 2. 计算 SS1 和 SS2

$$
\begin{align*}
SS1 &= ((A \lll 12) + E + T_j^{\text{rot}}) \bmod 2^{32} \\
SS1 &= SS1 \lll 7 \\
SS2 &= SS1 \oplus (A \lll 12)
\end{align*}
$$

### 3. 计算 TT1 和 TT2

- **FF 函数**：
  - $j < 16$: $FF = A \oplus B \oplus C$
  - $j \geq 16$: $FF = (A \land B) \lor (A \land C) \lor (B \land C)$

- **GG 函数**：
  - $j < 16$: $GG = E \oplus F \oplus G$
  - $j \geq 16$: $GG = (E \land F) \lor (\neg E \land G)$

- **TT1**:
  $$
  TT1 = FF + D + SS2 + W'_j
  $$

- **TT2**:
  $$
  TT2 = GG + H + SS1 + W_j
  $$

### 4. 更新寄存器（关键！顺序不能错）

```text
D ← C
C ← B ⋘ 9
B ← A
A ← TT1
H ← G
G ← F ⋘ 19
F ← E
E ← P0(TT2)
```

其中 $P_0(X) = X \oplus (X \lll 9) \oplus (X \lll 17)$

> ⚠️ 注意：所有加法为模 $2^{32}$，所有移位为 32 位循环左移。


## 第六步：更新链接变量

64 轮结束后，得到新状态 $(A, B, C, D, E, F, G, H)$

计算：
$$
V^{(1)} = V^{(0)} \oplus (A, B, C, D, E, F, G, H)
$$

即：
- $A_{\text{new}} = A_{\text{IV}} \oplus A_{\text{final}}$
- ……（其余同理）


## 第七步：输出哈希值

由于只有 1 个分组，$V^{(1)}$ 即为最终结果。

将 8 个 32 位字按**大端序拼接**，得到 256 位哈希值：

### ✅ 最终 SM3("abc") 结果：

```
expand = 512'h61626380000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018
SM3 = 256'h66c7f0f462eeedd9d1f2d46bdc10e4e24167c4875cf2f7a2297da02b8f4ba8e0
```


## 📌 关键说明

1. **所有运算基于 32 位字**，无字节级操作；
2. **循环左移（⋘）是核心扩散手段**；
3. **P₀ 和 P₁ 置换增强非线性**；
4. **前 16 轮与后 48 轮使用不同逻辑函数**，抵抗差分攻击；
5. **手算几乎不可行**，实际依赖库（如 GMSSL、BabaSSL）。

