# SHA-1计算步骤

SHA-1（Secure Hash Algorithm 1）的计算过程遵循一套明确的步骤，基于 **Merkle–Damgård 结构**。以下是其**完整的具体计算步骤**，适合理解或手动模拟（小数据）。


## SHA-1 具体计算步骤

### 输入
任意长度的消息 $ M $（以比特为单位）

### 输出
160 位（20 字节）的哈希值，通常表示为 40 位十六进制字符串。


## 步骤 1：消息填充（Padding）

目标：使消息长度 ≡ 448 (mod 512)，为后续添加 64 位长度字段留出空间。

1. 在消息末尾添加一个 **`1` 比特**。
2. 然后添加 **k 个 `0` 比特**，使得：
   $$
   (\text{原始长度} + 1 + k) \equiv 448 \pmod{512}
   $$
   即总长度 = 512×N − 64（对某个整数 N ≥ 1）。
3. 最后附加一个 **64 位大端序（big-endian）整数**，表示**原始消息的比特长度**（注意：是比特数，不是字节数）。

> 示例：若原始消息是 "abc"（3 字节 = 24 比特）  
> - 填充后总长需为 448 mod 512 → 最小满足的是 448  
> - 已有 24 + 1 = 25 位，需加 423 个 0  
> - 再加 64 位长度字段（值为 24）  
> - 总长 = 24 + 1 + 423 + 64 = **512 位 = 1 个块**


## 步骤 2：初始化哈希寄存器（H₀ ~ H₄）

使用 5 个 32 位寄存器，初始值（十六进制）为：

| 寄存器 | 初始值（十六进制） | 来源说明 |
|--------|-------------------|--------|
| H₀     | `0x67452301`      | √2 的小数部分前 32 位（大端） |
| H₁     | `0xEFCDAB89`      |
| H₂     | `0x98BADCFE`      |
| H₃     | `0x10325476`      |
| H₄     | `0xC3D2E1F0`      |

> 这些常量是固定的，所有 SHA-1 计算都从这里开始。


## 步骤 3：处理每个 512 位消息块

将填充后的消息划分为 **N 个 512 位（64 字节）的块**：$ M^{(1)}, M^{(2)}, \dots, M^{(N)} $

对每个块执行以下子步骤：

### 3.1 将 512 位块拆分为 16 个 32 位字（word）
记为：  
$$
W_0, W_1, \dots, W_{15}
$$  
（按大端序解析）

### 3.2 扩展为 80 个字（W₀ 到 W₇₉）
使用递推公式：
$$
W_i = \text{ROTL}_1(W_{i-3} \oplus W_{i-8} \oplus W_{i-14} \oplus W_{i-16}) \quad \text{for } i = 16 \text{ to } 79
$$

其中：
- $ \oplus $ 表示按位异或（XOR）
- $ \text{ROTL}_1(x) $ 表示将 32 位整数 x **循环左移 1 位**

> 这一步称为“消息调度”（Message Schedule）

### 3.3 初始化工作变量
$$
A = H_0,\quad B = H_1,\quad C = H_2,\quad D = H_3,\quad E = H_4
$$

### 3.4 执行 80 轮主循环

分为 **4 个阶段（每阶段 20 轮）**，使用不同的非线性函数和常量：

| 轮次范围 | 非线性函数 $ f(t) $                     | 常量 $ K_t $     |
|----------|------------------------------------------|--------------------|
| 0–19     | $ (B \land C) \lor (\lnot B \land D) $ | `0x5A827999`       |
| 20–39    | $ B \oplus C \oplus D $                | `0x6ED9EBA1`       |
| 40–59    | $ (B \land C) \lor (B \land D) \lor (C \land D) $ | `0x8F1BBCDC` |
| 60–79    | $ B \oplus C \oplus D $                | `0xCA62C1D6`       |

> 注：第 2 和第 4 阶段函数相同，但常量不同。

#### 每轮计算（t = 0 到 79）：
$$
\text{TEMP} = \text{ROTL}_5(A) + f(t) + E + K_t + W_t
$$
$$
E = D \\
D = C \\
C = \text{ROTL}_{30}(B) \\
B = A \\
A = \text{TEMP}
$$

其中：
- $ \text{ROTL}_5 $：循环左移 5 位
- $ \text{ROTL}_{30} $：循环左移 30 位（等价于右移 2 位）
- 所有加法为 **模 $ 2^{32} $** 的 32 位无符号整数加法

### 3.5 更新哈希寄存器
一轮块处理完后，更新全局哈希值：
$$
H_0 = H_0 + A \\
H_1 = H_1 + B \\
H_2 = H_2 + C \\
H_3 = H_3 + D \\
H_4 = H_4 + E
$$
（同样为模 $ 2^{32} $ 加法）


## 步骤 4：输出最终哈希值

将 $ H_0, H_1, H_2, H_3, H_4 $ 按顺序拼接（每个为 32 位大端序），形成 **160 位摘要**。

通常以 **40 位十六进制字符串**表示。


## 注意事项

- 所有整数运算均为 **32 位无符号**，溢出自动截断。
- 所有字节序为 **大端序（Big-endian）**。
- 循环移位是关键操作，不能用普通移位代替。
- SHA-1 已被攻破，**仅用于学习或非安全场景**。

