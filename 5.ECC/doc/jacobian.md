# Jacobian 坐标（Jacobian Coordinates）

使用 **Jacobian 坐标（Jacobian Coordinates）** 是在硬件中高效实现椭圆曲线点运算的标准方法，因为它**完全避免了模逆元（modular inversion）**，仅使用模加、模减和模乘。


## 背景：Jacobian 坐标表示

- 仿射坐标点 $ P = (x, y) $  
- Jacobian 坐标表示为 $ P = (X, Y, Z) $，其中：
  $$
  x = \frac{X}{Z^2}, \quad y = \frac{Y}{Z^3}
  $$
- 无穷远点 $ \mathcal{O} $ 表示为 $ (1, 1, 0) $ 或 $ (0, 1, 0) $（常用 $ Z = 0 $ 表示）

> 优点：点加/点倍公式中**无除法**，全部用模乘完成。


## 椭圆曲线方程（短 Weierstrass 形式）

$$
y^2 = x^3 + a x + b \mod p
$$

在 Jacobian 坐标下，等价于：
$$
Y^2 = X^3 + a X Z^4 + b Z^6 \mod p
$$

> 对于 **secp256k1**，有 $ a = 0 $，极大简化计算！

我们将以 **$ a = 0 $** 的通用情况实现（适用于 secp256k1）。


## 假设前提

- 曲线参数：$ a = 0 $（如 secp256k1）
- 所有输入点满足 $ Z \ne 0 $（非无穷远点）
- 已有以下基础模块（组合逻辑）：
  - `mod_add`
  - `mod_sub`
  - `mod_mul`


## 1. Jacobian 点倍（Point Doubling）— 2P

输入：$ P = (X_1, Y_1, Z_1) $  
输出：$ R = 2P = (X_3, Y_3, Z_3) $

### 公式：

$$
\begin{align*}
S &= 4 X_1 Y_1^2 \\
M &= 3 X_1^2 + a Z_1^4 \\
X_3 &= M^2 - 2S \\
Y_3 &= M(S - X_3) - 8 Y_1^4 \\
Z_3 &= 2 Y_1 Z_1
\end{align*}
$$

> 所有运算 mod $ p $


## 2. Jacobian 点加（Point Addition）— P + Q（P ≠ Q）

输入：
- $ P = (X_1, Y_1, Z_1) $
- $ Q = (X_2, Y_2, Z_2) $

输出：$ R = P + Q = (X_3, Y_3, Z_3) $

### 公式（a = 0）：

$$
\begin{align*}
U_1 &= X_1 Z_2^2 \\
U_2 &= X_2 Z_1^2 \\
S_1 &= Y_1 Z_2^3 \\
S_2 &= Y_2 Z_1^3 \\
H &= U_2 - U_1 \\
r &= S_2 - S_1 \\
X_3 &= r^2 - H^3 - 2 U_1 H^2 \\
Y_3 &= r(U_1 H^2 - X_3) - S_1 H^3 \\
Z_3 &= H Z_1 Z_2
\end{align*}
$$

> 若 $ H = 0 $ 且 $ r = 0 $ → P = Q，应调用点倍  
> 若 $ H = 0 $ 且 $ r \ne 0 $ → P = -Q，结果为无穷远点（Z₃ = 0）


## 使用说明

- 这两个模块是**纯组合逻辑**，延迟由模乘链决定。
- 对于 **secp256k1**（a=0），可直接使用。
- 若 $ a \ne 0 $，点倍公式需额外项 $ + a Z_1^4 $，但大多数标准曲线（如 secp256k1、NIST P-256）都选择 $ a = -3 $ 或 $ 0 $ 以优化。


## 如何转回仿射坐标？

最后只需一次逆元

## 总结

| 操作 | 模乘次数（a=0） |
|------|----------------|
| Jacobian 点倍 | 4 次 |
| Jacobian 点加 | 11 次 |

远优于仿射坐标（每次点加需 1 次昂贵的模逆元 ≈ 100+ 次模乘）。
