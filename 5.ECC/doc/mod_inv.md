# 模逆元（modular inverse）

**模逆元（modular inverse）** 是椭圆曲线密码（ECC）硬件设计中的关键且昂贵的操作。目标是计算：

$$
c = a^{-1} \bmod p
$$

即找到一个整数 $ c \in [0, p) $，使得：

$$
(a \cdot c) \bmod p = 1
$$

其中 $ a \in [1, p-1] $，$ p $ 是素数（因此逆元一定存在）。

## 两种主流方法

| 方法 | 原理 | 适用场景 |
|------|------|--------|
| **费马小定理（Fermat’s Little Theorem）** | $ a^{-1} \equiv a^{p-2} \mod p $ | 固定大素数（如 secp256k1），可用模幂实现 |
| **扩展欧几里得算法（Extended GCD）** | 解 $ ax + py = 1 \Rightarrow x = a^{-1} \mod p $ | 通用，适合任意素数，硬件效率高 |

> **实际 ECC 硬件中，通常避免使用模逆元！**  
> 而是采用 **投影坐标（如 Jacobian）** 将点加/倍转换为仅含模加、模乘的运算，最后只做一次逆元转回仿射坐标。

## 方法一：费马小定理 + 模幂（适合仿真或固定曲线）

适用于已知 $ p $（如 secp256k1），通过快速幂计算 $ a^{p-2} \mod p $。

### 缺点：
- $ p-2 $ 是 256 位大指数 → 需要 ~256 次模乘（double-and-multiply）
- 速度慢，面积大

### 优点：
- 逻辑简单，易于验证

## 方法二：扩展欧几里得算法（推荐用于硬件）

### 算法原理（迭代版）：
初始化：
- $ r_0 = p, \quad r_1 = a $
- $ t_0 = 0, \quad t_1 = 1 $

循环直到 $ r_1 = 0 $：
- $ q = r_0 / r_1 $（整数除法）
- $ (r_0, r_1) \leftarrow (r_1, r_0 - q \cdot r_1) $
- $ (t_0, t_1) \leftarrow (t_1, t_0 - q \cdot t_1) $

最终：若 $ r_0 = 1 $，则 $ t_0 \mod p $ 即为逆元。

### 优势：
- 平均约 $ \log_2 p $ 步（~256 步 for 256-bit）
- 每步只需除法、乘法、减法
- 可流水线或迭代实现

## 更好的做法：避免模逆元！

在 ECC 中，**不要在每次点加时都算逆元**。改用 **Jacobian 投影坐标**：

- 点表示为 $ (X, Y, Z) $，对应仿射坐标 $ (X/Z^2, Y/Z^3) $
- 点加/倍公式只含模加、模乘
- 最后只需 **一次逆元** 转回仿射坐标

例如，Jacobian 下点倍无需除法！

## 总结

| 方案 | 是否推荐 | 说明 |
|------|--------|------|
| **Fermat + 模幂** | 仅仿真 | 太慢，256 次模乘 |
| **扩展欧几里得** | 可用 | 需高效除法器，适合 ASIC |
| **Jacobian 坐标** | 强烈推荐 | 几乎完全避免逆元 |
