# Keccak算法结构

## 一、核心设计理念：海绵结构（Sponge Construction）

Keccak 放弃了传统哈希（如 MD5、SHA-1/2）使用的 **Merkle–Damgård 结构**，转而采用 **海绵结构**，具有以下优势：

- 支持任意输入/输出长度
- 天然抵抗长度扩展攻击
- 可统一构建哈希、MAC、伪随机数生成器、流密码等

### 海绵结构三要素：

| 参数 | 含义 |
|------|------|
| $ b $ | 内部状态总比特数（通常为 1600） |
| $ r $ | 比特率（rate）——每次吸收/输出的数据块大小 |
| $ c $ | 容量（capacity）——隐藏部分，决定安全性 |

满足：  
$$
b = r + c
$$

> 安全强度 ≈ $ c / 2 $ 比特（例如 $ c = 512 $ → 256 比特安全）

### 工作流程：

#### 1. **填充（Padding）**
将输入消息 $ M $ 填充为 $ r $-bit 块的整数倍。  
Keccak 使用 **多进制填充规则**（multi-rate padding）：  
$$
\text{pad}(M) = M \parallel 1 \parallel 0^k \parallel 1
$$  
其中 $ k $ 是最小非负整数，使得总长度 ≡ 0 (mod $ r $)。

> ⚠️ 注意：**原始 Keccak 与 SHA-3 的填充不同**  
> - 原始 Keccak：`10*1`  
> - SHA-3：在消息前加域分离前缀 `01`，实际填充为 `0110*1`（即以字节 `0x06` 开始）

#### 2. **初始化**
内部状态 $ S $ 初始化为全 0，大小为 $ b $ 比特（通常 1600）。

#### 3. **吸收阶段（Absorbing）**
将填充后的消息按 $ r $-bit 分块 $ M_0, M_1, ..., M_{t-1} $：
- 对每个块 $ M_i $：
  - 将 $ M_i $ 与状态 $ S $ 的前 $ r $ 位异或
  - 执行置换函数 $ f = \text{Keccak-}f[b] $

#### 4. **挤压阶段（Squeezing）**
- 输出哈希值：
  - 取状态 $ S $ 的前 $ r $ 位作为输出块
  - 若需更多输出，则再次执行 $ f $，继续取前 $ r $ 位
  - 直到获得所需长度的输出

> 由于 $ c $ 部分从未暴露，攻击者无法控制或预测内部状态演化。


## 二、置换函数：Keccak-f[b]

Keccak-f[1600] 的 **24 轮执行** 是 Keccak 哈希算法的核心，每一轮对 1600 比特的内部状态进行确定性、可逆（但密码学上单向）的非线性变换。下面将**逐轮、逐步骤、逐操作**详细说明如何执行这 24 轮，包括数据结构、运算规则和关键常数。


### 1、前提：状态表示

Keccak-f[1600] 的状态是一个 **1600 比特** 的比特串，逻辑上组织为一个三维数组：

$$
A[x][y] \quad \text{其中 } x, y \in \{0,1,2,3,4\}
$$

- 每个 $ A[x][y] $ 是一个 **64 位字**（w = 64）
- 总大小：$ 5 \times 5 \times 64 = 1600 $ 比特

> 💡 实际实现中，可用 `uint64_t state[5][5]` 表示。


### 2、24 轮循环结构

对轮数 $ i = 0 $ 到 $ 23 $，依次执行以下 **5 个步骤**（顺序固定）：

$$
\text{Round}_i = \iota_i \circ \chi \circ \pi \circ \rho \circ \theta
$$

即：先 θ，再 ρ，再 π，再 χ，最后 ι（注意函数复合顺序是从右到左）。


### 3、每轮五步详解

#### 步骤 1）：θ（Theta）—— 全局线性扩散

**目的**：在列之间引入扩散，使每一比特影响多列。

##### 计算过程：
1. 对每个 $ x \in \{0..4\} $，计算列奇偶校验：
   $$
   C[x] = A[x][0] \oplus A[x][1] \oplus A[x][2] \oplus A[x][3] \oplus A[x][4]
   $$

2. 对每个 $ x $，计算扩散值：
   $$
   D[x] = C[(x - 1) \bmod 5] \oplus \text{ROT}(C[(x + 1) \bmod 5],\ 1)
   $$
   - `ROT(w, 1)` 表示对 64 位字 `w` **循环左移 1 位**

3. 更新状态：
   $$
   A[x][y] = A[x][y] \oplus D[x] \quad \forall y \in \{0..4\}
   $$

> ✅ 此步是**线性**的，但提供强扩散。


#### 步骤 2）：ρ（Rho）—— 位移混淆

**目的**：通过不同位移打破对称性，增强雪崩效应。

##### 操作：
对每个 $ (x, y) \neq (0, 0) $，将 $ A[x][y] $ **循环左移** $ r[x][y] $ 位。

- $ A[0][0] $ **不移动**。
- 位移量 $ r[x][y] $ 由预定义表给出（基于数学序列）：

| (x, y) | 位移量 $ r[x][y] $ |
|--------|---------------------|
| (1,0)  | 1                   |
| (2,0)  | 62                  |
| (3,0)  | 28                  |
| (4,0)  | 27                  |
| (0,1)  | 36                  |
| (1,1)  | 44                  |
| (2,1)  | 6                   |
| (3,1)  | 55                  |
| (4,1)  | 20                  |
| (0,2)  | 3                   |
| (1,2)  | 10                  |
| (2,2)  | 43                  |
| (3,2)  | 25                  |
| (4,2)  | 39                  |
| (0,3)  | 41                  |
| (1,3)  | 45                  |
| (2,3)  | 15                  |
| (3,3)  | 21                  |
| (4,3)  | 8                   |
| (0,4)  | 18                  |
| (1,4)  | 2                   |
| (2,4)  | 61                  |
| (3,4)  | 56                  |
| (4,4)  | 14                  |

> 📌 共 24 个非零位移（25 个位置减去 (0,0)）。

#### 步骤 3）：π（Pi）—— 位置置换

**目的**：重新排列 5×5 网格中的字位置，实现跨行/列混淆。

##### 映射规则：
$$
(x, y) \longrightarrow (x', y') = \big( (x + 3y) \bmod 5,\ x \big)
$$

等价于：
$$
A_{\text{new}}[x'][y'] = A_{\text{old}}[x][y]
$$

> 🔁 这是一个**固定置换**，无密钥，但打乱空间结构。


#### 步骤 4）：χ（Chi）—— 唯一非线性层

**目的**：引入非线性，抵抗线性/差分攻击。

##### 操作（逐行独立）：

对每个 $ y \in \{0..4\} $，更新该行：
$$
A[x][y] = A[x][y] \oplus \left( (\neg A[(x+1)\bmod 5][y]) \ \&\ A[(x+2)\bmod 5][y] \right)
$$

> ❗ 这是整个 Keccak-f 中**唯一的非线性操作**。


#### 步骤 5）：ι（Iota）—— 轮常数异或

**目的**：打破轮间对称性，防止不动点和滑动攻击。

##### 操作：
将一个 64 位轮常数 $ RC[i] $ 异或到 $ A[0][0] $：

$$
A[0][0] = A[0][0] \oplus RC[i]
$$

##### 轮常数 $ RC[i] $：

| i | RC[i] (hex) |
|---|-------------|
| 0 | 0x0000000000000001 |
| 1 | 0x0000000000008082 |
| 2 | 0x800000000000808A |
| 3 | 0x8000000080008000 |
| 4 | 0x000000000000808B |
| 5 | 0x0000000080000001 |
| 6 | 0x8000000080008081 |
| 7 | 0x8000000000008009 |
| 8 | 0x000000000000008A |
| 9 | 0x0000000000000088 |
| 10 | 0x0000000080008009 |
| 11 | 0x000000008000000A |
| 12 | 0x000000008000808B |
| 13 | 0x800000000000008B |
| 14 | 0x8000000000008089 |
| 15 | 0x8000000000008003 |
| 16 | 0x8000000000008002 |
| 17 | 0x8000000000000080 |
| 18 | 0x000000000000800A |
| 19 | 0x800000008000000A |
| 20 | 0x8000000080008081 |
| 21 | 0x8000000000008080 |
| 22 | 0x0000000080000001 |
| 23 | 0x8000000080008008 |

> 📌 只有 $ A[0][0] $ 被修改，其他位置不变。


### 4、关键特性总结

| 特性 | 说明 |
|------|------|
| **可逆性** | Keccak-f 是双射（可逆），但哈希不可逆（因吸收/挤压丢弃信息） |
| **效率** | 无查表（table-free），抗缓存侧信道攻击 |
| **并行性** | θ、χ 可并行处理；ρ/π 为简单位移/重排 |
| **安全性** | 24 轮远超已知攻击所需（目前最佳攻击仅对 ≤6 轮有效） |


## 三、参数配置（SHA-3 实例）

| 算法名      | 输出长度 | $ r $ | $ c $ | 安全强度 |
|------------|--------|--------|--------|--------|
| SHA3-224   | 224    | 1152   | 448    | 112    |
| SHA3-256   | 256    | 1088   | 512    | 256    |
| SHA3-384   | 384    | 832    | 768    | 384    |
| SHA3-512   | 512    | 576    | 1024   | 512    |

> 注：容量 $ c $ 越大，安全性越高，但速度越慢。

