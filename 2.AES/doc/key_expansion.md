# 密钥扩展（Key Expansion）

AES 的**密钥扩展（Key Expansion）** 是将原始密钥（128/192/256 位）扩展成多个**轮密钥（Round Keys）** 的过程，供每一轮加密（或解密）使用。这些轮密钥总长度为：

- AES-128：10 轮 + 初始轮 → 共 **11 个轮密钥** × 128 位 = **44 个 32 位字（words）**
- AES-192：12 轮 + 初始轮 → **52 个 words**
- AES-256：14 轮 + 初始轮 → **60 个 words**

> AES 内部以 **32 位字（word）** 为单位处理密钥。128 位密钥 = 4 个 word，192 位 = 6 个 word，256 位 = 8 个 word。

---

## 一、基本概念

- 原始密钥被划分为 `Nk` 个 32 位字（word）：
  - AES-128: `Nk = 4`
  - AES-192: `Nk = 6`
  - AES-256: `Nk = 8`

- 扩展后得到 `Nb × (Nr + 1)` 个字，其中：
  - `Nb = 4`（因为分组是 128 位 = 4 个 word）
  - `Nr` 是轮数（10/12/14）

所以总字数 = `4 × (Nr + 1)`

---

## 二、密钥扩展算法步骤（以 AES-128 为例）

设扩展密钥数组为 `w[0] ... w[43]`（共 44 个 word）

### 步骤 1：初始化前 Nk 个字
```text
for i = 0 to Nk-1:
    w[i] = original_key_word[i]
```
即直接把原始密钥填入 `w[0]` 到 `w[3]`。

### 步骤 2：递推生成后续字
对 `i = Nk` 到 `43`（即 4 到 43）：

```text
if i % Nk == 0:
    temp = w[i-1]
    temp = SubWord(RotWord(temp)) XOR Rcon[i/Nk]
    w[i] = w[i-Nk] XOR temp
else:
    w[i] = w[i-Nk] XOR w[i-1]
```

#### 关键子操作说明：

1. **RotWord(word)**  
   将 4 字节的 word 循环左移 1 字节。  
   例如：`[a0, a1, a2, a3] → [a1, a2, a3, a0]`

2. **SubWord(word)**  
   对 word 的每个字节独立应用 AES 的 **S-Box**（与加密中的 SubBytes 相同）。

3. **Rcon[i]**（Round Constant）  
   一个只依赖于轮数 `i` 的常量，定义在 GF(2⁸) 上：
   ```
   Rcon[1] = 0x01000000
   Rcon[2] = 0x02000000
   Rcon[3] = 0x04000000
   Rcon[4] = 0x08000000
   ...
   Rcon[i] = (x^(i-1), 0x00, 0x00, 0x00)
   ```
   其中 `x` 是 GF(2⁸) 中的本原元（通常用 0x02 表示），乘法按 AES 定义的不可约多项式 `m(x) = x⁸ + x⁴ + x³ + x + 1` 进行。

   前几个 Rcon 值（十六进制）：
   | i | Rcon[i]（32位，大端） |
   |---|------------------------|
   | 1 | 0x01000000             |
   | 2 | 0x02000000             |
   | 3 | 0x04000000             |
   | 4 | 0x08000000             |
   | 5 | 0x10000000             |
   | 6 | 0x20000000             |
   | 7 | 0x40000000             |
   | 8 | 0x80000000             |
   | 9 | 0x1B000000             | ← 注意：0x80×2 = 0x100 → 模 m(x) 后 = 0x1B
   |10 | 0x36000000             |

> 注意：Rcon 索引从 1 开始，对应第 1 轮密钥生成。

---

## 三、举例：AES-128 密钥扩展片段

假设原始密钥（16 字节）为：
```
2b 7e 15 16 28 ae d2 a6 ab f7 15 88 09 cf 4f 3c
```
划分为 4 个 word（小端 or 大端？AES 使用**大端字节序**，按列主序）：
- w[0] = 0x2b7e1516
- w[1] = 0x28aed2a6
- w[2] = 0xabf71588
- w[3] = 0x09cf4f3c

计算 w[4]（因为 i=4, Nk=4, i%Nk==0）：

1. temp = w[3] = 0x09cf4f3c  
2. RotWord(temp) = 0xcf4f3c09  
3. SubWord(0xcf4f3c09) → 对每个字节查 S-Box：
   - 0xcf → 0x8a
   - 0x4f → 0x84
   - 0x3c → 0xeb
   - 0x09 → 0x01  
   ⇒ SubWord result = 0x8a84eb01  
4. Rcon[1] = 0x01000000  
5. temp = 0x8a84eb01 XOR 0x01000000 = 0x8b84eb01  
6. w[4] = w[0] XOR temp = 0x2b7e1516 XOR 0x8b84eb01 = **0xa0fafe17**

这就是第一个扩展出的新 word，用于第 1 轮的轮密钥。

---

## 四、轮密钥如何使用？

每轮使用 4 个连续的 word（128 位）作为轮密钥：

- 初始 AddRoundKey 使用：w[0]–w[3]
- 第 1 轮使用：w[4]–w[7]
- 第 2 轮使用：w[8]–w[11]
- ...
- 第 10 轮使用：w[40]–w[43]

---

## 五、AES-192 和 AES-256 的差异

- **AES-192（Nk=6）**：  
  条件变为 `if i % 6 == 0`，且当 `i % 6 == 4` 时，**额外对 temp 做 SubWord**（这是为了增强安全性）。  
  即：
  ```c
  if (i % Nk == 0)
      temp = SubWord(RotWord(w[i-1])) ^ Rcon[i/Nk];
  else if (Nk > 6 && i % Nk == 4)
      temp = SubWord(w[i-1]);  // only for AES-256? Actually for Nk>6, i%Nk==4
  else
      temp = w[i-1];
  w[i] = w[i-Nk] ^ temp;
  ```

- **AES-256（Nk=8）**：同样有 `i % 8 == 4` 时做 SubWord。

> 这是为了防止密钥调度中的某些对称性弱点。

---

## 六、总结

密钥扩展的核心思想：
- 利用原始密钥和非线性变换（S-Box）、循环移位、轮常量，生成看似随机但可重现的轮密钥序列。
- 每轮密钥都与原始密钥相关，但彼此不同，确保每轮加密的混淆性。
- Rcon 的引入打破对称性，防止等价密钥攻击。

