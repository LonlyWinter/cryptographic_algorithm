# 密钥扩展

SM4 算法中，**每一轮使用的密钥（称为“轮密钥”或 RK）是通过主密钥（128 位）经过一个固定的密钥扩展过程派生出来的**。整个过程共生成 **32 个轮密钥**（RK₀ 到 RK₃₁），分别用于 32 轮加密。

下面用**通俗、非公式化的方式**详细说明 SM4 轮密钥的生成过程：

### 一、输入：主密钥

- 用户提供一个 **128 位（16 字节）的主密钥**。
- 将其拆成 **4 个 32 位字**，记作：  
  `MK = (MK₀, MK₁, MK₂, MK₃)`

### 二、引入两个固定常量

1. **系统参数 FK（Fixed Key）**  
    这是一个固定的 4 字常量，用于“初始化扰动”，防止弱密钥。  
    值为：
    ```
    FK₀ = 0xA3B1BAC6  
    FK₁ = 0x56AA3350  
    FK₂ = 0x677D9197  
    FK₃ = 0xB27022DC
   ```

2. **轮常量 CK（Constant Key）**  
    共有 32 个（CK₀ 到 CK₃₁），每个也是 32 位。  
    它们是**预先定义好的常数**，用于确保每一轮的密钥扩展结果不同。  
    生成规则（标准中给出）：
    - CKᵢ 的第 j 位（j = 0~31）由一个简单的线性反馈移位寄存器（LFSR）生成；
    - 实际使用时，**直接查表即可**，无需实时计算。
    ```
    00070E15, 1C232A31, 383F464D, 545B6269,
    70777E85, 8C939AA1, A8AFB6BD, C4CBD2D9,
    E0E7EEF5, FC030A11, 181F262D, 343B4249,
    50575E65, 6C737A81, 888F969D, A4ABB2B9,
    C0C7CED5, DCE3EAF1, F8FF060D, 141B2229,
    30373E45, 4C535A61, 686F767D, 848B9299,
    A0A7AEB5, BCC3CAD1, D8DFE6ED, F4FB0209,
    10171E25, 2C333A41, 484F565D, 646B7279
    ```

### 三、密钥扩展步骤（生成中间状态）

1. **先对主密钥做一次“白化”处理**：  
   把主密钥的 4 个字分别与 FK 的 4 个字异或，得到初始的 4 个内部状态字：
   ```
   K₀ = MK₀ ⊕ FK₀  
   K₁ = MK₁ ⊕ FK₁  
   K₂ = MK₂ ⊕ FK₂  
   K₃ = MK₃ ⊕ FK₃
   ```

2. **循环 32 次，每次生成一个轮密钥 RKᵢ**：

   对于 i 从 0 到 31：
   - 先把当前的 Kᵢ、Kᵢ₊₁、Kᵢ₊₂、Kᵢ₊₃ 这 4 个字进行类似加密的混合操作：
     - 将后 3 个字（Kᵢ₊₁, Kᵢ₊₂, Kᵢ₊₃）异或在一起；
     - 再与轮常量 CKᵢ 异或；
     - 把结果送入一个**特殊的变换函数 T'**（注意：不是加密用的 T 函数！）；
   - T' 函数也包含 S 盒替换 + 一个**不同的线性扩散层 L'**（比加密中的 L 更简单）；
   - 把 T' 的输出与 Kᵢ 异或，得到下一个状态字 Kᵢ₊₄；
   - **同时，这个 Kᵢ₊₄ 就作为本轮的轮密钥 RKᵢ**。

   > 换句话说：**RKᵢ = Kᵢ ⊕ T'(Kᵢ₊₁ ⊕ Kᵢ₊₂ ⊕ Kᵢ₊₃ ⊕ CKᵢ)**

3. 每次迭代后，状态窗口向前滑动一位，继续下一轮，直到生成全部 32 个 RK。

### 四、变换函数T'


#### 1、T' 函数的作用

在密钥扩展中，每一轮需要生成一个 32 位的中间值，这个值既要：
- 依赖主密钥，
- 又要与轮常量 CK 结合，
- 还要具备**强非线性**和**扩散性**，

于是就用 **T' 函数**来处理这个 32 位输入，输出一个“打乱后”的 32 位结果，作为当前轮的轮密钥 RKᵢ。


#### 2、T' 函数的结构（两步走）

T' 函数由两个子步骤组成：

##### 第一步：S 盒非线性替换（τ 变换）
- 输入一个 32 位（4 字节）的数据。
- 把这 4 个字节**分别独立地查 SM4 的 S 盒**（就是加密中用的那个固定 256 字节表）。
- 得到 4 个新的字节，重新组合成一个 32 位字。

这一步提供**非线性混淆**，是安全性的关键。

##### 第二步：线性扩散变换（L' 变换）
- 对上一步的 32 位结果，进行**固定的位移和异或操作**，让每一位的变化能快速扩散到整个字。
- 具体操作（用自然语言描述）：

> 将输入记为 A（32 位），则 L'(A) 的计算方式为：  
> **A ⊕ (A <<< 13) ⊕ (A <<< 23)**  
> 其中 `<<<` 表示**循环左移**（rotate left）。

> 注意：这里的移位是 **13 位 和 23 位**，而**不是**加密中 T 函数用的 2、10、18、24 位！

所以，L' 是一个比加密中 L 更简单的线性变换，但仍能保证良好的扩散效果。


#### 3、T' 与 T 函数的区别总结

| 特性 | **T 函数（用于加密）** | **T' 函数（用于密钥扩展）** |
|------|------------------------|------------------------------|
| 使用阶段 | 加密/解密的 32 轮主流程 | 密钥扩展（生成 RK） |
| 非线性部分 | 相同的 S 盒（τ） | 相同的 S 盒（τ） |
| 线性部分 | L(A) = A ⊕ (A<<<2) ⊕ (A<<<10) ⊕ (A<<<18) ⊕ (A<<<24) | L'(A) = A ⊕ (A<<<13) ⊕ (A<<<23) |
| 移位位数 | 2, 10, 18, 24 | 13, 23 |
| 目的 | 强扩散，抵抗差分/线性攻击 | 足够扩散 + 高效，防止轮密钥相关性 |

> 关键点：**S 盒一样，线性层不同**。这是 SM4 设计的精妙之处——复用 S 盒，但用不同线性结构区分用途。


#### 4、T' 函数工作流程图（文字版）

```
输入：32 位数据 X
       ↓
[ 拆成 4 个字节 ]
       ↓
[ 每个字节查 S 盒 ] → 得到 4 个新字节
       ↓
[ 合并为 32 位 Y ]
       ↓
[ 计算 Y ⊕ (Y 循环左移13位) ⊕ (Y 循环左移23位) ]
       ↓
输出：32 位结果 = T'(X)
```


#### 5、为什么这样设计？

- **效率**：L' 只做两次移位+异或，比 L 更快，适合在密钥扩展阶段批量生成 32 个 RK。
- **安全性**：即使攻击者知道部分轮密钥，也难以通过 L' 的逆推导出 S 盒输入，因为 S 盒是非线性的。
- **隔离性**：T 和 T' 不同，避免加密过程与密钥扩展之间产生代数关联，提升整体抗攻击能力。


### 五、关键点总结

| 项目 | 说明 |
|------|------|
| **轮密钥数量** | 32 个，每个 32 位（共 128 字节） |
| **依赖主密钥** | 是，所有 RK 都由主密钥派生 |
| **是否可逆** | 否，密钥扩展是单向的（但不需要逆过程） |
| **S 盒是否参与** | 是！T' 函数中也使用了和加密相同的 S 盒 |
| **线性变换不同** | 是，密钥扩展用的是 L'，加密用的是 L，两者结构不同 |
| **轮常量作用** | 确保即使主密钥相同，每轮 RK 也不同，防止对称性攻击 |

### 六、为什么这样设计？

- **避免轮密钥重复或相关性**：通过 CK 和非线性 T'，保证 32 个 RK 彼此差异大。
- **抵抗密钥恢复攻击**：即使知道部分 RK，也很难反推出主密钥。
- **高效实现**：整个过程可在加密前一次性完成，不影响加解密速度。

### 六、示例（概念性）

假设主密钥是 `0x01234567 89abcdef fedcba98 76543210`，  
经过与 FK 异或、再循环 32 次后，可能得到：

```
RK₀  = 0xf12186f9
RK₁  = 0x41662b61
RK₂  = 0x5a6ab19a
...
RK₃₁ = 0x7a9fec7d
```

这些 RK 会在加密的第 1 轮到第 32 轮依次使用。

> 解密时，只需将 RK 顺序反转：用 RK₃₁ 作为第 1 轮密钥，RK₃₀ 作为第 2 轮……RK₀ 作为第 32 轮。



